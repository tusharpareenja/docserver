/*
 * (c) Copyright Ascensio System SIA 2010-2024
 *
 * This program is a free software product. You can redistribute it and/or
 * modify it under the terms of the GNU Affero General Public License (AGPL)
 * version 3 as published by the Free Software Foundation. In accordance with
 * Section 7(a) of the GNU AGPL its Section 15 shall be amended to the effect
 * that Ascensio System SIA expressly excludes the warranty of non-infringement
 * of any third-party rights.
 *
 * This program is distributed WITHOUT ANY WARRANTY; without even the implied
 * warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR  PURPOSE. For
 * details, see the GNU AGPL at: http://www.gnu.org/licenses/agpl-3.0.html
 *
 * You can contact Ascensio System SIA at 20A-6 Ernesta Birznieka-Upish
 * street, Riga, Latvia, EU, LV-1050.
 *
 * The  interactive user interfaces in modified source and object code versions
 * of the Program must display Appropriate Legal Notices, as required under
 * Section 5 of the GNU AGPL version 3.
 *
 * Pursuant to Section 7(b) of the License you must retain the original Product
 * logo when distributing the program. Pursuant to Section 7(e) we decline to
 * grant you any rights under trademark law for use of our trademarks.
 *
 * All the Product's GUI elements, including illustrations and icon sets, as
 * well as technical writing content are licensed under the terms of the
 * Creative Commons Attribution-ShareAlike 4.0 International. See the License
 * terms at http://creativecommons.org/licenses/by-sa/4.0/legalcode
 *
 */

'use strict';

const crypto = require('crypto');
const runtimeConfigManager = require('../../../Common/sources/runtimeConfigManager');
const passwordManager = require('./passwordManager');

const BOOTSTRAP_TOKEN_TTL = 1 * 60 * 60 * 1000; // 1 hour
const BOOTSTRAP_CODE_LENGTH = 12; // 12 chars = ~62 bits entropy (4.7 quintillion combinations)

/**
 * Bootstrap secret for HMAC-based code generation and verification
 * REQUIRED for cluster: All pods must use the same ADMINPANEL_BOOTSTRAP_SECRET env variable
 * This enables stateless verification across multiple nodes
 */
const BOOTSTRAP_SECRET = process.env.ADMINPANEL_BOOTSTRAP_SECRET || crypto.randomBytes(32).toString('hex');

if (!process.env.ADMINPANEL_BOOTSTRAP_SECRET) {
  console.info('ADMINPANEL_BOOTSTRAP_SECRET not set. Bootstrap codes will not work in cluster mode!');
}

/**
 * In-memory cache for current bootstrap code (for display only)
 * Actual verification is stateless and works across all cluster nodes
 */
let cachedBootstrapCode = null;

/**
 * Generate deterministic bootstrap code from timestamp and secret
 * All cluster nodes with same secret will generate/verify same code for same time window
 *
 * @param {number} timestamp - Timestamp to generate code for
 * @returns {string} 12-character code like "AB12CD34EF56"
 */
function generateShortCode(timestamp) {
  // Round timestamp to TTL window (1 hour) for deterministic generation
  const timeWindow = Math.floor(timestamp / BOOTSTRAP_TOKEN_TTL);

  // Generate HMAC-based code using secret and time window
  const hmac = crypto.createHmac('sha256', BOOTSTRAP_SECRET).update(`bootstrap:${timeWindow}`).digest('hex');

  // Convert to readable alphanumeric code
  const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';
  let code = '';
  for (let i = 0; i < BOOTSTRAP_CODE_LENGTH; i++) {
    const byte = parseInt(hmac.substring(i * 2, i * 2 + 2), 16);
    code += chars[byte % chars.length];
  }
  return code;
}

/**
 * Generate bootstrap token for initial setup
 * Code is deterministic based on time window and secret (cluster-safe)
 * All pods with same secret will generate same code for current time window
 *
 * @param {import('../../../Common/sources/operationContext').Context} ctx - Operation context
 * @returns {Promise<{code: string, expiresAt: Date}>}
 */
async function generateBootstrapToken(ctx) {
  const now = Date.now();
  const code = generateShortCode(now);
  const expiresAt = new Date(Math.ceil(now / BOOTSTRAP_TOKEN_TTL) * BOOTSTRAP_TOKEN_TTL);

  // Cache for display (same code will be generated by all nodes)
  cachedBootstrapCode = {
    code,
    expiresAt,
    generatedAt: now
  };

  ctx.logger.info('Bootstrap code generated (valid until %s)', expiresAt.toISOString());

  return {code, expiresAt};
}

/**
 * Verify bootstrap code from user input
 * Stateless verification - works across all cluster nodes with same secret
 * Verifies that code matches HMAC signature for current or previous time window
 *
 * @param {import('../../../Common/sources/operationContext').Context} ctx - Operation context
 * @param {string} providedCode - Code provided by user (e.g. "AB12CD34EF56")
 * @returns {Promise<boolean>} True if code is valid and not expired
 */
async function verifyBootstrapToken(ctx, providedCode) {
  if (!providedCode) {
    ctx.logger.warn('Bootstrap code verification failed: empty code');
    return false;
  }

  // Normalize code (remove spaces, dashes, uppercase)
  const normalizedCode = providedCode.toUpperCase().replace(/[\s-]/g, '');

  // Validate format
  if (normalizedCode.length !== BOOTSTRAP_CODE_LENGTH || !/^[A-Z0-9]+$/.test(normalizedCode)) {
    ctx.logger.warn('Bootstrap code verification failed: invalid format');
    return false;
  }

  // Check if setup already completed
  // Invalid or old format is treated as no password set
  const config = await runtimeConfigManager.getConfig(ctx);
  const passwordHash = config?.adminPanel?.passwordHash;

  if (passwordManager.isValidPasswordHash(passwordHash)) {
    ctx.logger.warn('Bootstrap code rejected: setup already completed');
    return false;
  }

  if (passwordHash && !passwordManager.isValidPasswordHash(passwordHash)) {
    ctx.logger.info('Invalid password hash format detected - allowing bootstrap for re-setup');
  }

  // Stateless verification: check if code matches current or previous time window
  // This allows codes from any pod in cluster, as long as they have same secret
  const now = Date.now();

  // Check current time window
  const currentCode = generateShortCode(now);
  if (currentCode === normalizedCode) {
    ctx.logger.info('Bootstrap code verified successfully (current window)');
    cachedBootstrapCode = null; // Clear cache
    return true;
  }

  // Check previous time window (in case code was generated at window boundary)
  const previousCode = generateShortCode(now - BOOTSTRAP_TOKEN_TTL);
  if (previousCode === normalizedCode) {
    ctx.logger.info('Bootstrap code verified successfully (previous window)');
    cachedBootstrapCode = null; // Clear cache
    return true;
  }

  ctx.logger.warn('Bootstrap code verification failed: invalid or expired code');
  return false;
}

/**
 * Check if bootstrap code exists and is valid in cache
 * Note: Code is always valid if setup not completed (cluster-wide)
 * @returns {boolean} True if cached bootstrap code exists and not expired
 */
function hasValidBootstrapToken() {
  if (!cachedBootstrapCode) {
    return false;
  }

  // Check expiration
  if (cachedBootstrapCode.expiresAt < new Date()) {
    cachedBootstrapCode = null; // Clear expired cache
    return false;
  }

  return true;
}

/**
 * Invalidate bootstrap code cache (for reset scenarios)
 * Note: Code itself remains valid across cluster until time window expires
 * @param {import('../../../Common/sources/operationContext').Context} ctx - Operation context
 */
async function invalidateBootstrapToken(ctx) {
  cachedBootstrapCode = null;
  ctx.logger.info('Bootstrap code cache cleared');
}

/**
 * Get current bootstrap code for display
 * Generates fresh code based on current time window (cluster-safe)
 * @returns {string|null} Current code or null
 */
function getCurrentBootstrapCode() {
  if (hasValidBootstrapToken()) {
    return cachedBootstrapCode.code;
  }
  return null;
}

module.exports = {
  generateBootstrapToken,
  verifyBootstrapToken,
  hasValidBootstrapToken,
  invalidateBootstrapToken,
  getCurrentBootstrapCode,
  BOOTSTRAP_TOKEN_TTL
};
